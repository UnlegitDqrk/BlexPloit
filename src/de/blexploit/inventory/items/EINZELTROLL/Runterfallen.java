package de.blexploit.inventory.items.EINZELTROLL;

import java.util.ArrayList;
import java.util.HashMap;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.BlockState;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.PlayerDeathEvent;

import de.blexploit.Start;
import de.blexploit.inventory.creator.Bereich;
import de.blexploit.inventory.creator.InvItem;
import de.blexploit.players.Getrollts;
import de.blexploit.players.Mittrollers;
import de.blexploit.players.create.GetrolltEntity;
import de.blexploit.players.create.MittrollerEntity;

public final class Runterfallen extends InvItem implements Listener {

	public Runterfallen() {
		super("Runterfallen", "Lässte den Spieler durch den Boden fallen", Material.LEVER, 0, Bereich.EINZELTROLL,
				false);
	}

	ArrayList<Player> todeath = new ArrayList<Player>();

	@Override
	public void right_click(MittrollerEntity mt) {
		spielerInfo(mt, "startet einen Freefalltower!");
		for (GetrolltEntity gt : Getrollts.getOnlines()) {
			todeath.add(gt.getPlayer());
		}
		runnable();
	}

	HashMap<Player, ArrayList<BlockState>> rollback = new HashMap<Player, ArrayList<BlockState>>();

	int shedule;

	private void runnable() {
		if (Bukkit.getScheduler().isCurrentlyRunning(shedule)) {
			return;
		}
		shedule = Bukkit.getScheduler().scheduleSyncRepeatingTask(Start.instance, new Runnable() {

			@SuppressWarnings("deprecation")
			@Override
			public void run() {
				for (Player g : todeath) {
					g.setFlying(false);
					for (int x = -2; x < 2; x++) {
						for (int z = -2; z < 2; z++) {
							for (int y = -1; y < 0; y++) {
								final Location bchange = new Location(g.getWorld(), g.getLocation().getBlockX() + x,
										g.getLocation().getBlockY() + y, g.getLocation().getBlockZ() + z);
								final int ioldb = bchange.getBlock().getTypeId();
								final byte boldb = bchange.getBlock().getData();
								if (!rollback.containsKey(g)) {
									ArrayList<BlockState> bs = new ArrayList<BlockState>();
									bs.add(bchange.getBlock().getState());
									rollback.put(g, bs);
								} else {
									ArrayList<BlockState> bs = rollback.get(g);
									boolean allow = true;
									for (BlockState find : bs) {
										if (find.getBlock().getLocation().equals(bchange.getBlock().getLocation())) {
											allow = false;
										}
									}
									if (allow) {
										bs.add(bchange.getBlock().getState());
										rollback.put(g, bs);
									}

								}
								bchange.getBlock().setType(Material.AIR);
								Bukkit.getScheduler().scheduleSyncDelayedTask(Start.instance, new Runnable() {

									@Override
									public void run() {
										for (Player onlines : Bukkit.getOnlinePlayers()) {
											onlines.sendBlockChange(bchange, ioldb, boldb);
										}
									}
								}, 4);
							}
						}
					}
				}
			}
		}, 4, 4);
	}

	@Override
	public void left_click(MittrollerEntity mt) {
		Mittrollers.sendMessage("§a" + mt.getPlayername() + ChatColor.BLUE + " fängt die Spieler auf!");
		for (Player p : todeath) {
			if (rollback.containsKey(p)) {
				ArrayList<BlockState> rb = rollback.get(p);
				for (BlockState bs : rb) {
					bs.update(true);
				}
			}
		}
		todeath.clear();
		rollback.clear();
		Bukkit.getScheduler().cancelTask(shedule);
	}

	@EventHandler
	private void onDeath(PlayerDeathEvent e) {
		Player p = (Player) e.getEntity();
		if (todeath.contains(p)) {
			if (rollback.containsKey(p)) {
				ArrayList<BlockState> rb = rollback.get(p);
				for (BlockState bs : rb) {
					bs.update(true);
				}
				rollback.remove(p);
			}
			todeath.remove(p);
		}

	}

}
