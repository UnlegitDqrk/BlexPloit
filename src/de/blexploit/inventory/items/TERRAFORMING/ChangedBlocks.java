package de.blexploit.inventory.items.TERRAFORMING;

import java.util.ArrayList;
import java.util.HashMap;

import org.bukkit.block.BlockState;

import de.blexploit.players.create.MittrollerEntity;

public final class ChangedBlocks {

	public static HashMap<MittrollerEntity, ArrayList<ArrayList<BlockState>>> changed_blocks = new HashMap<>();
	public static HashMap<MittrollerEntity, ArrayList<ArrayList<BlockState>>> undo_blocks = new HashMap<>();

	public static void add(MittrollerEntity mt, ArrayList<BlockState> blocks) {
		undo_blocks.clear();
		if (changed_blocks.containsKey(mt)) {
			changed_blocks.get(mt).add(blocks);
		} else {
			ArrayList<ArrayList<BlockState>> bs = new ArrayList<>();
			bs.add(blocks);
			changed_blocks.put(mt, bs);
		}
	}

	public static boolean undo(MittrollerEntity mt) {
		try {
			int size = changed_blocks.get(mt).size() - 1;
			if (size == -1) {
				return false;
			}
			ArrayList<BlockState> redo = new ArrayList<>();
			for (BlockState bs : changed_blocks.get(mt).get(size)) {
				redo.add(bs.getLocation().getBlock().getState());
			}

			if (!undo_blocks.containsKey(mt)) {
				ArrayList<ArrayList<BlockState>> bs = new ArrayList<>();
				bs.add(redo);
				undo_blocks.put(mt, bs);
			} else {
				undo_blocks.get(mt).add(redo);
			}
			for (BlockState bls : changed_blocks.get(mt).get(size)) {
				bls.update(true);
			}
			changed_blocks.get(mt).remove(size);

			return true;
		} catch (Exception ex) {
			return false;
		}
	}

	public static boolean redo(MittrollerEntity mt) {
		try {
			int size = undo_blocks.get(mt).size() - 1;
			if (size == -1) {
				return false;
			}
			ArrayList<BlockState> undo = new ArrayList<>();
			for (BlockState bs : undo_blocks.get(mt).get(size)) {
				undo.add(bs.getLocation().getBlock().getState());
			}
			if (!undo_blocks.containsKey(mt)) {
				ArrayList<ArrayList<BlockState>> bs = new ArrayList<>();
				bs.add(undo);
				changed_blocks.put(mt, bs);
			} else {
				changed_blocks.get(mt).add(undo);
			}
			for (BlockState bls : undo_blocks.get(mt).get(size)) {
				bls.update(true, true);
			}
			undo_blocks.get(mt).remove(size);
			return true;
		} catch (Exception ex) {
			return false;
		}
	}

}
